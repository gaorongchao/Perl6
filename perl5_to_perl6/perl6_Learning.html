<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>perl6学习</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="title" content="perl6学习"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2014-05-10T11:30+0800"/>
<meta name="author" content="扶 凯"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">perl6学习</h1>


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 Github地址</a></li>
<li><a href="#sec-2">2 写在perl6之前</a></li>
<li><a href="#sec-3">3 perl6的安装</a></li>
<li><a href="#sec-4">4 学习perl6</a>
<ul>
<li><a href="#sec-4-1">4.1 字符串,数组和哈希</a>
<ul>
<li><a href="#sec-4-1-1">4.1.1 字符串strings</a></li>
<li><a href="#sec-4-1-2">4.1.2 数组</a></li>
</ul>
</li>
<li><a href="#sec-4-2">4.2 hash哈希</a></li>
<li><a href="#sec-4-3">4.3 Types 类型</a></li>
<li><a href="#sec-4-4">4.4 基本的控制结构</a>
<ul>
<li><a href="#sec-4-4-1">4.4.1 概要</a></li>
<li><a href="#sec-4-4-2">4.4.2 分支</a></li>
</ul>
</li>
<li><a href="#sec-4-5">4.5 Subroutines and Signatures 子程序和参数</a>
<ul>
<li><a href="#sec-4-5-1">4.5.1 语法</a></li>
<li><a href="#sec-4-5-2">4.5.2 描述</a></li>
<li><a href="#sec-4-5-3">4.5.3 Motivation真实意图</a></li>
</ul>
</li>
<li><a href="#sec-4-6">4.6 Objects and Classes</a>
<ul>
<li><a href="#sec-4-6-1">4.6.1 语法</a></li>
</ul>
</li>
<li><a href="#sec-4-7">4.7 Contexts 上下文</a>
<ul>
<li><a href="#sec-4-7-1">4.7.1 语法</a></li>
<li><a href="#sec-4-7-2">4.7.2 描述</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Github地址</h2>
<div class="outline-text-2" id="text-1">

<p><a href="https://github.com/gaorongchao/Perl6/tree/master/perl5_to_perl6">https://github.com/gaorongchao/Perl6/tree/master/perl5_to_perl6</a>
所有后续更新都在github上进行，其他地方不做同步。
发现任何错误，或者不当的地方，请先到github查看是否改正。
如果没有请留言。或者邮件交流：rongchaogao@gmail.com
</p></div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 写在perl6之前</h2>
<div class="outline-text-2" id="text-2">

<p>从95年到现在，很多年过去了，从perl6计划开始到现在，也有10年的时间了。
所有的事物都在不断的发展，或许perl6还要再开发10年，或者20年，但是未来
总是属于perl6的。与其等到40岁的时候再去学习一项新的东西，不如从现在开
始就积极拥抱perl6。
Perl6现在的版本Rakudo每个月都在更新新的版本。分为两种，一个是Rakudo，
一个是Rakudo star。大家可以选择安装。
</p>
<p>
我以前只翻译到第三部分，后面就没有翻译下去。扶凯兄基本上都翻译完成。
本翻译是在扶凯兄翻译的基础上，加工整理而成。
</p></div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> perl6的安装</h2>
<div class="outline-text-2" id="text-3">

<p>perl6的官方网站：perl6.org。上面有perl6相关的东西。其中Compilers
是Rakudo，也就是perl6的编译器。在rakudo.org里面我们可以下载。或者我
们可以用git来进行安装。在下载下来的rakudo中有一个install的文件，这里
包含了安装rakudo所需要的东西，和安装的信息，里面用Ubuntu作为例子，你
可以根据这个来进行安装。
</p>
<p>
同时现在提供Rakudo star 的安装包。为windows提供了MSI安装包。
<a href="http://rakudo.org/downloads/star/">http://rakudo.org/downloads/star/</a>
</p>
<p>
安装完成以后，修改一下环境变量，vim .bashrc,然后添加perl6所在的目录
就可以了。
</p></div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> 学习perl6</h2>
<div class="outline-text-2" id="text-4">

<p>我看的第一份资料是是从perl6.org/documentation/ 里下载的Perl 5 to 
perl 6.还有doc.perl6.org里面的的东西。
首先perl6中不用use strict;和use warnings;了，用了反而会报错。
</p>
</div>

<div id="outline-container-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> 字符串,数组和哈希</h3>
<div class="outline-text-3" id="text-4-1">

<p>用法
</p>


<pre class="example"><span class="linenr"> 1:  </span># 首先不需要use strict;use warnings;
<span class="linenr"> 2:  </span>
<span class="linenr"> 3:  </span>my $five =5 ;
<span class="linenr"> 4:  </span>print " $five\n";
<span class="linenr"> 5:  </span>say "five is $five";
<span class="linenr"> 6:  </span># 上面是一样的效果，say 自带换行符
<span class="linenr"> 7:  </span>
<span class="linenr"> 8:  </span>my @array =1,2,3,'foo';
<span class="linenr"> 9:  </span>my $sum=@array[0]+@array[1];
<span class="linenr">10:  </span>say "sum is $sum";
<span class="linenr">11:  </span># 数组的元素可以这样写了。
<span class="linenr">12:  </span>if $sum&gt;@array[2]
<span class="linenr">13:  </span>{
<span class="linenr">14:  </span>    say "not executed";
<span class="linenr">15:  </span>}
<span class="linenr">16:  </span># if 语句这样写了，不用括号了
<span class="linenr">17:  </span>my $number_of_elems=@array.elems;        
<span class="linenr">18:  </span># 下面这样也可以
<span class="linenr">19:  </span>my $number_of_elems=+@array;
<span class="linenr">20:  </span>say "number of elems $number_of_elems";
<span class="linenr">21:  </span># 数组元素的个数,不在支持$# 了。
<span class="linenr">22:  </span>
<span class="linenr">23:  </span>my $last_item=@array[*-1];
<span class="linenr">24:  </span>say "last item is $last_item";
<span class="linenr">25:  </span># 数组的最后一个元素
<span class="linenr">26:  </span>
<span class="linenr">27:  </span>my %hash= foo=&gt;1,bar=&gt;2,baz=&gt;3;
<span class="linenr">28:  </span>say "hash bar is  %hash{'bar'}";
<span class="linenr">29:  </span>say "hash bar is  %hash&lt;bar&gt;";# 和上面一样的效果
<span class="linenr">30:  </span># %hash{bar} 这样是错误的。
<span class="linenr">31:  </span># 这是要去找一个叫bar()的子程序，很显然我们这里没有定义。
<span class="linenr">32:  </span>
</pre>

<p>
perl6和perl5类似，只不过更好而已。一句话是由分号终止，
在一个语句块，或者大括号之间代码的最后一行，分号是可加，可不加的。
变量仍然由$,@,%等打头。许多perl5的功能依然健在。
</p>
</div>

<div id="outline-container-4-1-1" class="outline-4">
<h4 id="sec-4-1-1"><span class="section-number-4">4.1.1</span> 字符串strings</h4>
<div class="outline-text-4" id="text-4-1-1">

<p>字符串被双引号包括（变量内插）或者用单引号，反斜杠和perl5一样。
变量内插的规则有了一些变化，下面的情况将被变量内插
</p>


<pre class="example"><span class="linenr"> 1:  </span>my $scalar = 6;
<span class="linenr"> 2:  </span>my @array =1,2,3;
<span class="linenr"> 3:  </span>say "Perl scalar is $scalar";
<span class="linenr"> 4:  </span>say "array数组的所有元素 @array[]";       
<span class="linenr"> 5:  </span>#空索引，结果是整个数组，1，2，3
<span class="linenr"> 6:  </span>say "array 数组的第二个元素 @array[1]";
<span class="linenr"> 7:  </span>say "没有索引，不会显示数组的名称： @array"; 
<span class="linenr"> 8:  </span># 打印@array这几个字符
<span class="linenr"> 9:  </span>say "双引号内执行代码：Code:{$scalar*2}";  
<span class="linenr">10:  </span>#大括号中的部分会被看成代码，结果是内插的，结果是12
</pre>

<p>
数组和hash只有在后面跟着索引的时候，或者跟着以（）结尾的方法的时候才会变量内插。
如”some $obj.method()"),空的索引内插整个hash或者数组。
</p></div>

</div>

<div id="outline-container-4-1-2" class="outline-4">
<h4 id="sec-4-1-2"><span class="section-number-4">4.1.2</span> 数组</h4>
<div class="outline-text-4" id="text-4-1-2">

<p>数组变量仍然以@开头，但是不同的是即使取其中的单个元素也是以@开头的。
</p>


<pre class="example"><span class="linenr">1:  </span>my @a =5,1,2;                         
<span class="linenr">2:  </span>#列表是用逗号来分割构建的，不用括号了。
<span class="linenr">3:  </span>say "数组的所有元素 @a[]";
<span class="linenr">4:  </span>say "数组的第一个元素 @a[0]";            # 不再是$a[0]
<span class="linenr">5:  </span>say "数组的第一个和第三个元素 @a[0,2]";   # 数组切片仍然可以用
</pre>

<p>
列表是用逗号分割构建的。1,是一个列表，（1）不是。
</p>
<p>
由于现在一切都可以看成对象，你可以用数组的方法来对数组进行操作。
</p>


<pre class="example"><span class="linenr"> 1:  </span>my @a =5,1,2;             #列表是用逗号来分割构建的。
<span class="linenr"> 2:  </span>say "数组a @a[]";
<span class="linenr"> 3:  </span>
<span class="linenr"> 4:  </span>my @b=@a.sort;           #排序后的数组a
<span class="linenr"> 5:  </span>say "排序后的数组 @b[]";
<span class="linenr"> 6:  </span>my $num_of_array_b=@b.elems;
<span class="linenr"> 7:  </span>say "b的元素个数 $num_of_array_b";
<span class="linenr"> 8:  </span>if @b&gt;2 {say "如果元素个数大于2，yes"}
<span class="linenr"> 9:  </span>
<span class="linenr">10:  </span>my $end_of_array_b=@b.end;
<span class="linenr">11:  </span>say "b的最后一个元素的索引， $end_of_array_b";#替代了$#
<span class="linenr">12:  </span>my @c=@b.map({$_*2});    # map 同样还是一种方法。
<span class="linenr">13:  </span>say "数组c @c[]";
</pre>

<p>
这里有一种qw/../的简写形式：
</p>


<pre class="example"><span class="linenr">1:  </span>my @methods = &lt;shift unshift push pop end delete sort map&gt;;
</pre>

<p>
数组相关新方法
</p>


<pre class="example"><span class="linenr">1:  </span>@array.keys();       #取得数组的下标
<span class="linenr">2:  </span>@array.values();     #取得数组的值
<span class="linenr">3:  </span>@array.kv();         #下标和值一起取得
<span class="linenr">4:  </span>@array.elems();      #元素的个数
<span class="linenr">5:  </span>@array.exists(num)； #判断某个下标值是否存在，
<span class="linenr">6:  </span>@array.max()；       #最大值
<span class="linenr">7:  </span>@array.min()；       #最小值
</pre>



<pre class="example"><span class="linenr">1:  </span>@array.pick(num);   #随机取出数组中的不重复元素
<span class="linenr">2:  </span>#例子
<span class="linenr">3:  </span>my @array = &lt;a b c d e&gt;;
<span class="linenr">4:  </span>say @array.pick(4);
<span class="linenr">5:  </span>say @array.pick(*);#*代表所有元素
</pre>

</div>
</div>

</div>

<div id="outline-container-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> hash哈希</h3>
<div class="outline-text-3" id="text-4-2">

<p>Perl 5 中的哈希在列表环境中依然是一个列别。
但是Perl 6 在列表环境中是列表对。列表对在其他方面也有广泛应用，
比如，子程序中的具名参数。后面会有更多的应用。
如同数组一样，哈希也有不同的调用方法。
</p>


<pre class="example"><span class="linenr">1:  </span>my %drinks =
<span class="linenr">2:  </span>    France  =&gt; 'Wine',
<span class="linenr">3:  </span>    Bavaria =&gt; 'Beer',
<span class="linenr">4:  </span>    USA     =&gt; 'Coke';
<span class="linenr">5:  </span>say "The people in France love ",%drinks{'France'};
<span class="linenr">6:  </span>my @countries = %drinks.keys.sort;
<span class="linenr">7:  </span>#%drinks{'France'};现在的用法
<span class="linenr">8:  </span>#$drinks{France};  以前的用法
<span class="linenr">9:  </span>#%drinks&lt;France&gt;;  现在也可以这样用
</pre>

<p>
注意：当你访问hash的元素的时候%hash{&hellip;},键并不会自动添加引号,
%hash{foo}不是去访问foo的值，而是调用名称为foo()的子程序。自动quoting
并没有消失，只不过换了一种方式：
</p>


<pre class="example"><span class="linenr">1:  </span>say %drinks&lt;Bavaria&gt;;
</pre>

<p>
所有的内建方法，可以是method也可以是一个子程序，所以这两种方法
都对，sort @array 或者 @array.sort.<br/>
最后你要知道，所有的[..] {..}(occurring direct after a term)
仅仅是在使用一个特定的方法，而不是和数组和哈希绑定的。这意味着，他们并不在依赖于特殊的魔符。
</p>



<pre class="example"><span class="linenr">1:  </span>my $a = [1,2,3];
<span class="linenr">2:  </span>say $a[2];      #3
<span class="linenr">3:  </span>#this implies that you don't need special dereferencing syntax,and that you can
<span class="linenr">4:  </span>#act as arrays, hashes and subs at the same time.没整明白？？？
</pre>

<p>
从这里，我们可以看到，以后不用特殊的解引用的方法，并且您可以创建能同时充当数组，哈希和子程序的
对象。
</p></div>

</div>

<div id="outline-container-4-3" class="outline-3">
<h3 id="sec-4-3"><span class="section-number-3">4.3</span> Types 类型</h3>
<div class="outline-text-3" id="text-4-3">

<p>概要：
</p>


<pre class="example">my Int $x=3;
$x="foo";   # 这里会报错，原因是，我们上面一句把$x 
# 定义为Int也就是整数，但是这里我们却给他复制一个字符串
say $x.WHAT; # 'Int()'

# 检查一个变量的类型
if $x~~Int
{
    say '$x contains an Int';
｝
</pre>

<p>
在perl6中有了类型，所有的东西都可以看成一个对象，都有一个类型。
变量也可以有一个类型的约束，但是，不是必须需要一个类型。
</p>


<pre class="example"><span class="linenr">1:  </span>'a string'  #str字符串
<span class="linenr">2:  </span>2           #int整数型
<span class="linenr">3:  </span>3.14        #Rat (rational number)有理数
<span class="linenr">4:  </span>（1，2，3)   #Seq列表
</pre>

<p>
所有的内建类型都是大写字母开头，所有的标准类型都是继承了Any，并且所有的都继承了Mu
</p>



<pre class="example">#你可以在声明的时候，加上类型
my Numeric $x = 3.4;
my $Int @a = 1,2,3;
# 试图把一个值赋予一个错误的类型会提示出错

#对一个数组类型的类型定义，作用在数组的元素上，
#Str @s  @s这个数组只能够包含字符串元素的数组
</pre>

<p>
一些类型是隶属与一个大的分类，比如：整数型（Int），有理数（Rat），浮点型（Num）都是属于
Numeric这个大的类型
</p>



<pre class="example">#要知道一个对象的类型，可以使用.WHAT的方法
say "foo".WHAT;
#如果你要确定一个某变量是不是某一特殊类型，
#这里有一个一个不同的方法,这种方法把继承考虑在内
#在这里我们推荐使用这种方法
if $x ~~ Int
{
    say 'Variable $x contains an integer';
}
</pre>

<p>
虽然这种类型系统让我们很难彻底领悟它的所有细节。但是我们依然有很多理由使用它。
</p>
<p>
我们需要类型的原因：
</p><ul>
<li>1.编程更加安全
</li>
</ul>

<p>如果你声明了一个特殊的类型，那么你可以执行特定的某种操作，而不用检查
</p><ul>
<li>2.可优化
</li>
</ul>

<p>如果在编译的时候提供了类型，那么运行的程序会有明显的优化。在原则上perl6
不会比C慢
</p><ul>
<li>3.可扩展型
</li>
</ul>

<p>有了类型信息和多重的操作路径，你可以很容易对特定的类型改善操作
</p>
</div>

</div>

<div id="outline-container-4-4" class="outline-3">
<h3 id="sec-4-4"><span class="section-number-3">4.4</span> 基本的控制结构</h3>
<div class="outline-text-3" id="text-4-4">


</div>

<div id="outline-container-4-4-1" class="outline-4">
<h4 id="sec-4-4-1"><span class="section-number-4">4.4.1</span> 概要</h4>
<div class="outline-text-4" id="text-4-4-1">




<pre class="example"><span class="linenr"> 1:  </span>my $percent=120;
<span class="linenr"> 2:  </span>if $percent &gt;100
<span class="linenr"> 3:  </span>{
<span class="linenr"> 4:  </span>    say "weird mathematics";
<span class="linenr"> 5:  </span>}
<span class="linenr"> 6:  </span>
<span class="linenr"> 7:  </span>for 1..3
<span class="linenr"> 8:  </span>{
<span class="linenr"> 9:  </span>    #用$_作为默认循环的变量
<span class="linenr">10:  </span>    say 2*$_;
<span class="linenr">11:  </span>}
<span class="linenr">12:  </span>
<span class="linenr">13:  </span>for 1..3 -&gt; $x
<span class="linenr">14:  </span>{
<span class="linenr">15:  </span>    # 用一个明确的循环变量
<span class="linenr">16:  </span>    say 2*$x;
<span class="linenr">17:  </span>}
<span class="linenr">18:  </span>
<span class="linenr">19:  </span>while $stuff.is_wrong
<span class="linenr">20:  </span>{
<span class="linenr">21:  </span>    $stuff.try_to_make_right;
<span class="linenr">22:  </span>}
<span class="linenr">23:  </span>die "Access denied" unless $password eq "Secret";
<span class="linenr">24:  </span>
</pre>

<p>
perl6 和perl5 的控制结构基本相同，最大的不同是你不必在if,while,for等，后面添加
小括号了。事实上，所有的标示符后面紧跟着小括号，都会被看成在调用一个名称为if的子程序，
for后面加一个空格，可以改善这种情况，但是直接省略括号更加安全。
</p></div>

</div>

<div id="outline-container-4-4-2" class="outline-4">
<h4 id="sec-4-4-2"><span class="section-number-4">4.4.2</span> 分支</h4>
<div class="outline-text-4" id="text-4-4-2">

<ul>
<li>if控制结构：if结构是变化最小的，你依然可以用elsif和else，
</li>
</ul>

<p>unless也还在，但是在unless后面不允许else分支结构
</p>


<pre class="example"><span class="linenr">1:  </span>if $sheep == 0 {say "how boring";}
<span class="linenr">2:  </span>elsif $sheep ==1 {say "one lonely sheep";}
<span class="linenr">3:  </span>else {say "a herd,How lovely!";}
</pre>

<p>
你现在依然可以使用if和unless作为语句的修饰，也就是后声明的方式：
</p>


<pre class="example">say "you won" if $answer == 42;
</pre>

<ul>
<li>Loops：和perl5一样，你依然可以通过next和last来控制循环。
</li>
</ul>


<p>
在这里for循环只用于遍历列表，默认的变量依然是$_,同时你也可以显式的
声明一个循环变量。
</p>


<pre class="example"><span class="linenr">1:  </span>for 1..100 -&gt; $x
<span class="linenr">2:  </span>{
<span class="linenr">3:  </span>    say $x;#会输出1 2 3 。。
<span class="linenr">4:  </span>}
</pre>

<p>
-&gt;$x{..}被称为‘pointy block'如同匿名子程序或者lisp中的lambda。
</p>
<p>
当然，也可以有不止一个的循环变量。
</p>


<pre class="example">for 0..5 -&gt;$even,$odd
{
    say "Even: $even \t Odd: $odd";
}
#结果如下：
#Event:1     Odd:2
#Event:3     Odd:4
#也就是交替出现

#这个也是遍历哈希的方法
my %hash=
    a   =&gt; 1,
    b   =&gt; 2,
    c   =&gt; 3;
for %hash.kv -&gt; $key,$value
{
    say "$key: $value";
}

#C-风格的for循环,唯一需要括号的循环结构
loop （my $x=1;$x&lt;100;$x**2)
{
    say $x;
}
</pre>


</div>
</div>

</div>

<div id="outline-container-4-5" class="outline-3">
<h3 id="sec-4-5"><span class="section-number-3">4.5</span> Subroutines and Signatures 子程序和参数</h3>
<div class="outline-text-3" id="text-4-5">


</div>

<div id="outline-container-4-5-1" class="outline-4">
<h4 id="sec-4-5-1"><span class="section-number-4">4.5.1</span> 语法</h4>
<div class="outline-text-4" id="text-4-5-1">

<ul>
<li>Perl5 样式的子程序
</li>
</ul>




<pre class="example"># 没有signature(参数)
sub print_arguments 
{
        say "Arguments:";
        for (@_)
        {
                say "\t$_";
        }
}
my @argument = qw/1 2 3 4/;
print_arguments(@argument); 
</pre>

<ul>
<li>拥有参数名称和类型的子程序
</li>
</ul>




<pre class="example">sub distance (Int $x1, Int $y1, Int $x2, Int $y2)
{
        return sqrt ($x2-$x1)**2 + ($y2-$y1)**2;
}
say distance(3,5,0,1);
# 结果是3^2 + 4^2然后开方结果是5
</pre>

<ul>
<li>默认参数
</li>
</ul>




<pre class="example">sub logarithm($num,$base = 2.7183)
{
        return log($num)/log($base)
}
say logarithm(4);
# 1.38628
# 这里之提供了一个参数，所以第二个就是使用的默认的参数
say logarithm(4,2);
# 2
# 这里提供了两个参数，所以默认参数不再起作用
</pre>

<ul>
<li>具名参数（named arguments)
</li>
</ul>




<pre class="example">sub doit(:$when, :$what)
{
        say "doign $what at $when";
}
doit(what =&gt; "stuff",when =&gt; "once");
# doing stuff at onec
doit(:when&lt;noon&gt;, :what("more stuff"));
# doing more stuff at noon
</pre>

</div>

</div>

<div id="outline-container-4-5-2" class="outline-4">
<h4 id="sec-4-5-2"><span class="section-number-4">4.5.2</span> 描述</h4>
<div class="outline-text-4" id="text-4-5-2">

<p>子程序是又sub开头的关键字进行声明，可以拥有一系列的参数，
如同C,Java和其他大多数程序语言一样。
这些参数可以选择性的有类型的限制。
</p>
<p>
参数默认是只读的。但是可以通过所谓的“特性”来进行修改。
</p>


<pre class="example">sub try-to-reset($bar)
{
        $bar = 2; # 禁止的
}

my $x = 2;
sub reset($bar is rw)
{
        $bar=0; # 允许的
}
reset($x);
say $x; # 0

sub quox($bar is copy)
{
        $bar=3;
}
quox($x);
say $x; # is still 0
</pre>

<p>
参数可以通过在后面添加？进行选择性是否需要这个参数。
也可以通过提供一个默认值。
</p>


<pre class="example">sub foo($x,$y?)
{
        if $y.defined
        {
                say "Second parameter was supplied and defined";
        }
        else
        {
                say "Don't have second parameter!";
        }
}
foo(5,6); # Secon parameter was supplied and defined
foo(5);   # Don't have second parameter!
</pre>


<pre class="example">sub bar($x,$y=2*$x)
{
...
}
</pre>

<ul>
<li id="sec-4-5-2-1">具名参数<br/>
当你调用一个像这样的参数的时候：my<sub>sub</sub>($first,$second),
$first参数和第一个参数是绑定的，$second参数和第二个参数
是绑定的。这也是为什么称之为“位置参数“。

<p>
有些时候，名称比数字更好记忆，这是为什么Perl6有”具名参数的原因。
</p>


<pre class="example">my $r = Rectangle.new(
                x         =&gt; 100,
                y         =&gt; 200,
                height=&gt; 23,
                width =&gt; 42,
                color =&gt; "black");
</pre>

<p>
但你看到这种形式的东西的时候，你立马就能明白参数的意义。
为了定义一个具名参数，你只需要在参数前面添加一个冒号。
</p>


<pre class="example">sub area (:$width,:$height)
{
        return $width * $height;
}
area(width =&gt;2,height=&gt;3);
area(height =&gt;3,width=&gt;2);
area(:height(3),:width(2));
</pre>

<p>
最后一个例子用了所谓的“冒号配对”语法形式。
如果仅仅有留下名字，那么会赋值为"True",取反则会赋值为"False":
</p>


<pre class="example">:draw-perimeter      # same as "draw-perimeter=&gt;True"
:!transparent        # same as "transparent   =&gt;False"
</pre>

<p>
在具名参数的声明中，变量名同时用做参数的名字。你也可以用不同的名字：
</p>


<pre class="example">sub area (:width($w),:height($h))
{
    return $w*$h;
}
area(width=&gt;2,height=&gt;3);
</pre>

</li>
</ul>
<ul>
<li id="sec-4-5-2-2">Slurpy Parameters<br/>
仅仅给你的子程序命一个名字，并不意味着你事先知道子程序有多少个参数。
你可以定义所谓的slurpy parameters(在所有的正式的参数后面）可以
用所有的剩余参数。



<pre class="example">sub tail ($first, *@rest)
{
        say "first: $first";
        say "Rest: @rest[]";
}
tail(1,2,3,4);
# 结果是:First: 1 \n Rest:2 3 3\n";
</pre>

<p>
具名slurpy参数是通过在哈希参数前加星号来完成的。(??????)
</p>


<pre class="example">sub order-meal ($name,*%extras)
{
        say "I'd like somen $name, but with a few modifications:";
        say %extras.keys.join(', ');
}
order-meal ('beef steak', :vegetarian, :well-done);
</pre>

</li>
</ul>
<ul>
<li id="sec-4-5-2-3">Interpolation 变量内插<br/>
默认情况下，数组不能内插在变量中，与Perl5不同，你可以这些写：



<pre class="example">sub a($scalar1,@list,$scalar2)
{
        say $scalar2;
}
my @list = "foo","bar";
a(1,@list,2); # 2
</pre>

<p>
这也意味着你不能用列表来作为参数列表。
</p>


<pre class="example">my @indexes=1,4;
say "abc".substr(@indexes); # 结果是c
</pre>

<p>
（真实发生的事情是：这第一个参数可以是Int类型，如果不是，强制转换成Int.
所以你写成"abc."substr(@indexes.elems)是一样的。）
你可以通过使用使用潜前置的|来实现预定的功能：
</p>


<pre class="example">say "abcdefgh".substr(|@indexes) # bcde,same as "abcdefgh".substr(1,4);
</pre>

</li>
</ul>
<ul>
<li id="sec-4-5-2-4">Multi Subs 多样子程序<br/>
实际上，你可以用同一个子程序名称来定义多个具有不同参数列表的子程序。



<pre class="example">multi sub my_substr($str) {...}
multi sub my_substr($str,$start) {...}
multi sub my_substr($str,$start,$end) {...}
multi sub my_substr($str,$start,$end,$subst) {...}
</pre>

<p>
你定义好了以后，当你调用这种子程序的时候，其中能匹配参数列表的子程序将
被调用。
</p>
<p>
这种多样子程序不仅仅能够区分参数的个数，而且能能够区分参数的类型。
</p>


<pre class="example">multi sub frob (Str $s) {say "Frobbing String $s"}
multi sub frob (Int $i) {say "Frobbing Integer $i"}
frob ("x");
frob (2);
# 结果
# Frobbing String x
# Frobbing Integer 2

</pre>


</li>
</ul>
</div>

</div>

<div id="outline-container-4-5-3" class="outline-4">
<h4 id="sec-4-5-3"><span class="section-number-4">4.5.3</span> Motivation真实意图</h4>
<div class="outline-text-4" id="text-4-5-3">

<p>没人会怀疑给子程序参数一个明确名称的重要性：
更少的输入，更少的双重参数的检查，更多的自我说明性质的代码。
</p>
<p>
同时也允许有用的自省。
？？？？
</p></div>
</div>

</div>

<div id="outline-container-4-6" class="outline-3">
<h3 id="sec-4-6"><span class="section-number-3">4.6</span> Objects and Classes</h3>
<div class="outline-text-3" id="text-4-6">


</div>

<div id="outline-container-4-6-1" class="outline-4">
<h4 id="sec-4-6-1"><span class="section-number-4">4.6.1</span> 语法</h4>
<div class="outline-text-4" id="text-4-6-1">




<pre class="example">

</pre>

</div>
</div>

</div>

<div id="outline-container-4-7" class="outline-3">
<h3 id="sec-4-7"><span class="section-number-3">4.7</span> Contexts 上下文</h3>
<div class="outline-text-3" id="text-4-7">


</div>

<div id="outline-container-4-7-1" class="outline-4">
<h4 id="sec-4-7-1"><span class="section-number-4">4.7.1</span> 语法</h4>
<div class="outline-text-4" id="text-4-7-1">




<pre class="example">my @a = &lt;a b c&gt;;
my $x = @a;
say $x[2];
say (~2).WHAT;
say +@a;
if @a &lt;10 {say "short array";}
</pre>

</div>

</div>

<div id="outline-container-4-7-2" class="outline-4">
<h4 id="sec-4-7-2"><span class="section-number-4">4.7.2</span> 描述</h4>
<div class="outline-text-4" id="text-4-7-2">

<p>当你这样写的时候
</p>


<pre class="example">$x = @a;
</pre>

<p>
在Perl5中，$x 只包含@a的元素的数量。
为了保留所有的信心，你必须要用引用：$x = \@a;
</p>
<p>
在Perl6 中，用数值变量储存数组变量，你不会丢失任何东西。
这样为上下文和更多的特殊上下文（数值，整数，和字符串）做好了准备。
Void(空)和列表上下文没有变化。
你可以强制通过语法强制转换上下文环境。
</p>
</div>
</div>
</div>
</div>
</div>

<div id="postamble">
<p class="date">Date: 2014-05-10T11:30+0800</p>
<p class="author">Author: 扶 凯</p>
<p class="creator"><a href="http://orgmode.org">Org</a> version 7.9.3f with <a href="http://www.gnu.org/software/emacs/">Emacs</a> version 24</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>

</div>
</body>
</html>

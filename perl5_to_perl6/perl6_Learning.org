perl6学习
* 写在perl6之前
从95年到现在，很多年过去了，从perl6计划开始到现在，也有10年的时间了。
所有的事物都在不断的发展，或许perl6还要再开发10年，或者20年，但是未来
总是属于perl6的。与其等到40岁的时候再去学习一项新的东西，不如从现在开
始就积极拥抱perl6。
* perl6的安装
perl6的官方网站：perl6.org。上面有perl6相关的东西。其中Compilers
是Rakudo，也就是perl6的编译器。我们从这里面可以得到具体的安装信息。我
所有的工作都是在Ubuntu下进行的。在rakudo.org里面我们可以下载。或者我
们可以用git来进行安装。在下载下来的rakudo中有一个install的文件，这里
包含了安装rakudo所需要的东西，和安装的信息，里面用Ubuntu作为例子，你
可以根据这个来进行安装。
安装完成以后，修改一下环境变量，vim .bashrc,然后添加perl6所在的目录
就可以了。
* 学习perl6
我看的第一份资料是是从perl6.org/documentation/ 里下载的Perl 5 to 
perl 6.还有doc.perl6.org里面的的东西。
首先perl6中不用use strict;和use warnings;了，用了反而会报错。

** 字符串
用法
#+begin_src perl -n 
  my $fve = 5;
  print "an interpolating string, just like in perl $five\n";
  say 'say() adds a newline to the output,just like in perl 5.10';
  say 'new line with out \n";
  #这里的一个新的特性就是，say自动添加换行符。不用你手动加入了
#+end_src
貌似双引号的功能也有所改变，但是怎么改变的还没有具体的看到。\\
字符串被双引号包括（变量内插）或者用单引号，反斜杠和perl5一样。
变量内插的规则有了一些变化，下面的情况将被变量内插
#+begin_src perl -n
  my $scalar = 6;
  my @array =1,2,3;
  say "Perl $scalar";
  say "An @array[]";     #空索引，结果是整个数组，1，2，3
  say "@array[1]";
  say "Code:{$scalar*2}";#大括号中的部分会被看成代码，结果是内插的，结果是12
#+end_src
数组和hash只有在后面跟着索引的时候，或者跟着以（）结尾的方法的时候才会变量内插。
如”some $obj.method()"),空的索引内插整个hash或者数组。

** 数组
数组相关新方法
#+begin_src perl -n 
@array.keys();       #取得数组的下标
@array.values();     #取得数组的值
@array.kv();         #下标和值一起取得
@array.elems();      #元素的个数
@array.exists(num）； #判断某个下标值是否存在，
@array.max()；       #最大值
@array.min()；       #最小值
#+end_src
#+begin_src perl -n
  my @array = 1,2,3,'foo';        #括号不再需要
  my $sum = @array[0]+@array[1];  #单个数组元素也是以@开头
  my @array[1,3];                 #数组切片仍然可用
  my $num_of_element = @array.elems;
  #元素的个数，在perl6中通过这种方式，而不是各种奇怪的符号，
  my $num_of_element = +@array  #是求元素个数的另外一种方法。
  my $last_item = @array[*-1];  #数组的最后一个元素

#+end_src

#+begin_src perl -n
  @array.pick(num);   #随机取出数组中的不重复元素
  #例子
  my @array = <a b c d e>;
  say @array.pick(4);
  say @array.pick(*);#*代表所有元素
#+end_src
所有的都是对象，你可以call mechods on arrays；
#+begin_src perl -n
  my @array = <5 7 3 6>;
' #以前这样写@array = qw/5 7 3 6/；现在可以按照上面的方法写
  my @b = @a.sort; #对@array使用方法“排序”
  say @b;          #结果为3 5 6 7
  say @b.elems;    #数组元素，结果为4
  if @b > 2 {say “yes”}
  say @b.end;      #最后一个元素的下标，结果为3
  my @c = @b.map ({$_*2});
  say @c；         #结果为6 10 12 14
  
#+end_src
** hash
#+begin_src perl -n
  my %drinks =
      France  => 'Wine',
      Bavaria => 'Beer',
      USA     => 'Coke';
  say "The people in France love ",%drinks{'France'};
  my @countries = %drinks.keys.sort;
  #%drinks{'France'};现在的用法
  #$drinks{France};  以前的用法
  #%drinks<France>;  现在也可以这样用
#+end_src
所有的内建方法，可以是method也可以是一个子程序，所以这两种方法
都对，sort @array @array.sort.\\
最后你要知道，所有的[..] {..}(occurring direct after a term)
仅仅是在使用一个特定的方法，而不是和数组和hash想相联系的。
#+begin_src perl -n
  my $a = [1,2,3];
  say $a[2];      #3
  #this implies that you don't need special dereferencing syntax,and that you can
  #act as arrays, hashes and subs at the same time.没整明白？？？
#+end_src

** Types 类型
在perl6从都有类型，所有的东西都可以看成一个对象，都有一个类型。
变量也可以有一个类型的约束，但是不是必须需要一个类型。
#+begin_src perl -n
     'a string'  #str字符串
    2           #int整数型
    3.14        #Rat (rational number)有理数
    （1，2，3)   #Seq列表
  #所有的内建类型都是大写字母开头，所有的标准类型都是继承了Any，并且所有的都继承了Mu
  
  #你可以在声明的时候，加上类型
  my Numeric $x = 3,4;
  my $Int @a 1,2,3;
  
  #对一个数组类型的类型定义，作用在数组的元素上，
  #Str @s  @s这个数组只能够包含字符串元素的数组
  
  #一些类型是隶属与一个大的分类，比如：整数型（Int），有理数（Rat），浮点型（Num）都是属于
  #Numeric这个大的类型
  
  #要知道一个对象的类型，可以使用.WHAT的方法
  say "foo".WHAT;
  #如果你要确定一个特殊类型的方法，还有一个方法，
  if $x ~~ Int
  {
      say 'Variable $x contains an integer';
  }
#+end_src
我们需要类型的原因\\
1.编程更加安全\\
如果你声明了一个特殊的类型，那么你可以执行特定的某种操作，而不用检查\\
2.可优化的\\
如果在编译的时候提供了类型，那么运行的程序会有明显的优化。在原则上perl6
不会比C慢\\
3.可扩展型\\
有了类型信息和多重的操作路径，你可以很容易对特定的类型改善操作

** 基本的控制结构
perl6 和perl5 的控制结构基本相同，最大的不同是你不必在if,while,for等，后面添加
小括号了。事实上所有的标示符后面紧跟着小括号，都会被看成在调用子程序一个名称为if的子
程序，for后面加一个空格，可以改善这种情况，但是直接省略括号更加安全。\\
if控制结构
#+begin_src perl -n
  #if结构是变化最小的，你依然可以用elsif和else，unless也还在，但是在unless后面不允许else
  #分支结构
  if $sheep == 0 {say "how boring";}
  elsif $sheep ==1 {say "one lonely sheep";}
  else {say "a herd,How lovely!";}
  
  #你依然可以这样用
  say "you won" if $answer == 42;
#+end_src
Loops
#+begin_src perl -n
  for 1..100 -> $x
  {
      say $x;#会输出1 2 3 。。
  }
  #->$x{..}被称为‘pointy block'如同匿名子程序或者lisp中的lambda
  #也可以有不止一个的循环变量
  for 0..5 ->$even,$odd
  {
      say "Even: $even \t Odd: $odd";
  }
  #结果如下：
  #Event:1     Odd：2
  #也就是交替出现
  
  #这个也是hash的迭代的方法
  my %hash=
      a   => 1,
      b   => 2,
      c   => 3;
  for %hash.kv -> $key,$value
  {
      say "$key: $value";
  }
  
  #C-风格的for循环
  loop （my $x=1;$x<100;$x**2)
  {
      say $x;
  }
#+end_src

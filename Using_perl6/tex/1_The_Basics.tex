% Created 2014-03-22 Sat 15:14
\documentclass[11pt]{ctexart}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fixltx2e}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{soul}
\usepackage{textcomp}
\usepackage{marvosym}
\usepackage{wasysym}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{hyperref}
\tolerance=1000
\providecommand{\alert}[1]{\textbf{#1}}

\title{2: The Basics}
\author{GRC(扬眉剑)}
\date{\today}
\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs Org-mode version 7.9.3f}}

\begin{document}

\maketitle

\setcounter{tocdepth}{3}
\tableofcontents
\vspace*{1cm}
\section{第二章：基础}
\label{sec-1}

Perl起源于一个致力于从文本文件中收集整理信息的编程语言。
现在Perl在文本处理方面仍然强大，Perl 5 是一个一般意义上的强力编程语言。
但是Perl 6更为杰出。

假设你举办了一个乒乓球联赛。
裁判告诉你比赛结果的格式：选手1 选手2 | 3:2,这意味着，选手1赢了3局，选手2赢了2局。
你需要一个脚本来，来统计选手赢了几场比赛，赢了多少局，并以此决定最终冠军的归属。

输入文件格式如下(储存在一个名为“scores”的文件中)：\\

\begin{verbatim}
Beth Ana Charlie Dave 
Ana Dave            |  3:0
Charlie Beth        |  3:1
Ana Beth            |  2:3
Dave Charlie        |  3:0
Ana Charlie         |  3:1
Beth Dave           |  0:3
\end{verbatim}

第一行是所有选手的名字，后面跟着的是每场比赛的结果。
这里有一个解决此问题的Perl 6 脚本:perl-1-1：

\begin{verbatim}
1 use v6;
2
3 my $file = open 'scores';
4 my @names = $file.get.words;
5
6 my %matches;
7 my %sets;
8
9 for $file.lines -> $line {
10 my ($pairing, $result) = $line.split(' | ');
11 my ($p1, $p2) = $pairing.words;
12 my ($r1, $r2) = $result.split(':');
13
14 %sets{$p1} += $r1;
15 %sets{$p2} += $r2;
16
17 if $r1 > $r2 {
18 %matches{$p1}++;
19 } else {
20 %matches{$p2}++;
21 }
22 }
23
24 my @sorted = @names.sort({ %sets{$_} }).sort({ %matches{$_} }).reverse;
25
26 for @sorted -> $n {
27 say "$n has won %matches{$n} matches and %sets{$n} sets";
28 }
\end{verbatim}
输出文件：

\begin{verbatim}
Ana has won 2 matches and 8 sets
Dave has won 2 matches and 6 sets
Charlie has won 1 matches and 4 sets
Beth has won 1 matches and 4 sets
\end{verbatim}
每一个Perl6程序都需要以 “use v6”; 开始。这一行告诉编译器Perl代码的版本。
如果，你不小心用Perl5来运行这个程序，你将得到错误信息。

一个Perl6程序包含0行或者更多的语句。每一个语句以分号结尾，或者以大括号结尾：

\begin{verbatim}
my $file = open 'scores';
\end{verbatim}
``my''声明一个词法变量。词法变量只在当前代码块可用，从声明开始到代码块的结束。
如果一个代码块始终没有闭合，那么该变量可以在剩下的所有地方使用。代码块的定义是：
一段在花括号{}之间的代码。

一个变量名称以“魔符”开始，魔符是指那些非字母，非数字的符号，比如：\$,@,\% 或者\&-
或者有时出现的双冒号“::”也是。
魔符指明了变量的结构类型，比如：它应该被当作一个值，还是多个值，还是一个子程序，等等。
跟在“魔符”后面的是“标识符”，标识符可以包含字母，数字和下划线。在字母与字母之间，
你可以用短横线“-”或者撇号“'”。所以“isn't”和“double-click”都是合法的变量标识符。

魔符“\$”表明变量是一个数值变量，指明这个变量只存储了一个值。

内建函数“open”打开了一个名为“scores”的文件，然后返回一个文件句柄，
文件句柄是一个代表该文件的对象。
赋值符号“=”，把文件句柄赋值给左边的变量，这也就是意味着变量\$file现在存储着文件句柄。

“scores”是字符串文本（string literal）。字符串（string）是一段纯文本。
字符串文本（string literal)是直接出现在程序中的字符串。
在这一行中，它是提供给open函数的参数。


\begin{verbatim}
my @names = $file.get.words;
\end{verbatim}
上面语句的左侧调用了一种“方法”（一个命名的一系列行为的集合体）获取存储在\$file变量中的句柄。
被命名为get的这一方法从文件中读取并返回一行，去掉末尾的换行符。word同样是一个方法，调用从
get中返回的一行文本。word这一方法，分解它的invocant（它要操作的字符串）成一些列的单词。
这里单词的意思是不包含空格的字符串。它把字符串“Beth Ana Charlie Dave”分解成多个字符串
“Beth”,“Ana”,“Charlie”,“Dave”。

最后，这一字符串列表存储到数组@names中。魔符@表明所声明的变量是一个数组。数组存储的是有序列表。


\begin{verbatim}
my %matches;
my %sets;
\end{verbatim}

\end{document}
